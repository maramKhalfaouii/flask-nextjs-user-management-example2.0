{"ast":null,"code":"function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport jwtDecode from \"jwt-decode\";\nexport class AuthToken {\n  constructor(token) {\n    this.token = token;\n    _defineProperty(this, \"decodedToken\", void 0);\n    // we are going to default to an expired decodedToken\n    this.decodedToken = {\n      id: 0,\n      exp: 0,\n      iat: 0\n    };\n\n    // then try and decode the jwt using jwt-decode\n    try {\n      if (token) this.decodedToken = jwtDecode(token);\n    } catch (e) {}\n  }\n  get authorizationString() {\n    return `Bearer ${this.token}`;\n  }\n  get expiresAt() {\n    return new Date(this.decodedToken.exp * 1000);\n  }\n  get isExpired() {\n    return new Date() > this.expiresAt;\n  }\n  get isValid() {\n    return !this.isExpired;\n  }\n}","map":{"version":3,"names":["jwtDecode","AuthToken","constructor","token","_defineProperty","decodedToken","id","exp","iat","e","authorizationString","expiresAt","Date","isExpired","isValid"],"sources":["/usr/src/app/utils/auth/auth-token.ts"],"sourcesContent":["import jwtDecode from \"jwt-decode\";\n\nexport type DecodedToken = {\n  readonly exp: number;\n  readonly iat: number;\n  readonly id: number;\n};\n\nexport class AuthToken {\n  readonly decodedToken: DecodedToken;\n\n  constructor(readonly token?: string) {\n    // we are going to default to an expired decodedToken\n    this.decodedToken = { id: 0, exp: 0, iat: 0 };\n\n    // then try and decode the jwt using jwt-decode\n    try {\n      if (token) this.decodedToken = jwtDecode(token);\n    } catch (e) {}\n  }\n\n  get authorizationString() {\n    return `Bearer ${this.token}`;\n  }\n\n  get expiresAt(): Date {\n    return new Date(this.decodedToken.exp * 1000);\n  }\n\n  get isExpired(): boolean {\n    return new Date() > this.expiresAt;\n  }\n\n  get isValid(): boolean {\n    return !this.isExpired;\n  }\n}\n"],"mappings":";;;AAAA,OAAOA,SAAS,MAAM,YAAY;AAQlC,OAAO,MAAMC,SAAS,CAAC;EAGrBC,WAAWA,CAAUC,KAAc,EAAE;IAAA,KAAhBA,KAAc,GAAdA,KAAc;IAAAC,eAAA;IACjC;IACA,IAAI,CAACC,YAAY,GAAG;MAAEC,EAAE,EAAE,CAAC;MAAEC,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAE,CAAC;;IAE7C;IACA,IAAI;MACF,IAAIL,KAAK,EAAE,IAAI,CAACE,YAAY,GAAGL,SAAS,CAACG,KAAK,CAAC;IACjD,CAAC,CAAC,OAAOM,CAAC,EAAE,CAAC;EACf;EAEA,IAAIC,mBAAmBA,CAAA,EAAG;IACxB,OAAQ,UAAS,IAAI,CAACP,KAAM,EAAC;EAC/B;EAEA,IAAIQ,SAASA,CAAA,EAAS;IACpB,OAAO,IAAIC,IAAI,CAAC,IAAI,CAACP,YAAY,CAACE,GAAG,GAAG,IAAI,CAAC;EAC/C;EAEA,IAAIM,SAASA,CAAA,EAAY;IACvB,OAAO,IAAID,IAAI,CAAC,CAAC,GAAG,IAAI,CAACD,SAAS;EACpC;EAEA,IAAIG,OAAOA,CAAA,EAAY;IACrB,OAAO,CAAC,IAAI,CAACD,SAAS;EACxB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module"}